### কেন Transaction এবং Locking প্রয়োজন?

Database-এ যখন আমরা কোনো ডাটা রিড করার পাশাপাশি সেটি আপডেট করি (যেমন: একটি পোস্ট পড়া এবং সাথে সাথে তার ভিউ কাউন্ট বাড়ানো), তখন **Transaction** এবং **Locking** ব্যবহার করা খুবই জরুরি। এটি নিশ্চিত করে যে, একই সময়ে একাধিক ইউজার পোস্টটি দেখলেও ভিউ কাউন্ট যেন সঠিকভাবে আপডেট হয়।

নিচে বিষয়টি ব্যাখ্যা করা হলো:

মনে করুন, একটি পোস্টের বর্তমান ভিউ সংখ্যা ১০০। দুইজন ইউজার (A এবং B) একই সেকেন্ডে পোস্টটি ওপেন করলেন।

1. ইউজার A ডাটাবেস থেকে সংখ্যাটি পড়লেন (১০০)।
2. ইউজার B-ও ডাটাবেস থেকে সংখ্যাটি পড়লেন (১০০)।
3. ইউজার A এক বাড়িয়ে আপডেট করলেন (১০০ + ১ = ১০১)।
4. ইউজার B-ও এক বাড়িয়ে আপডেট করলেন (১০০ + ১ = ১০১)।

**সমস্যা:** দুইজন দেখার পর ভিউ হওয়া উচিত ছিল ১০২, কিন্তু হলো ১০১। এটাকে বলা হয় **Race Condition**। ট্রানজ্যাকশন এবং `FOR UPDATE` লক এই সমস্যা সমাধান করে।

---

### স্টেপ-বাই-স্টেপ প্রক্রিয়া (Logic)

একটি ট্রানজ্যাকশনের মধ্যে সাধারণত এই তিনটি কাজ হয়:

1. **Transaction Start:** ডাটাবেসকে বলা যে একটি নিরাপদ কাজ শুরু হচ্ছে।
2. **Select with Lock:** পোস্টটি খুঁজে বের করা এবং ওই রো (row) টিকে 'লক' করে দেওয়া যাতে অন্য কেউ সেটি পরিবর্তন করতে না পারে।
3. **Update & Commit:** ভিউ কাউন্ট ১ বাড়িয়ে সেভ করা এবং ট্রানজ্যাকশন শেষ করা।

---

### প্র্যাকটিক্যাল কোড উদাহরণ

নিচে একটি জনপ্রিয় ORM ব্যবহার করে উদাহরণ দেওয়া হলো:

```ts
const express = require("express");
const { PrismaClient } = require("@prisma/client");

const prisma = new PrismaClient();
const app = express();

app.use(express.json());

// একটি নির্দিষ্ট পোস্ট দেখার API (GET Request)
app.get("/post/:id", async (req, res) => {
  const postId = Number(req.params.id);

  if (isNaN(postId)) {
    return res.status(400).json({ error: "Invalid ID format" });
  }

  try {
    // ট্রানজ্যাকশন শুরু
    const updatedPost = await prisma.$transaction(async (tx) => {
      // ১. চেক করা পোস্টটি আছে কি না
      const post = await tx.post.findUnique({
        where: { id: postId },
      });

      if (!post) {
        throw new Error("Post not found");
      }

      // ২. ভিউ কাউন্ট ১ বাড়ানো এবং ডাটা আপডেট করা
      const postWithNewView = await tx.post.update({
        where: { id: postId },
        data: {
          viewCount: {
            increment: 1, // ডাটাবেস লেভেলে +১ হবে
          },
        },
      });

      return postWithNewView; // আপডেট হওয়া পোস্টটি ট্রানজ্যাকশন থেকে বের করে আনা
    });

    // সাকসেস রেসপন্স পাঠানো
    res.json({
      message: "Post fetched and view count updated",
      data: updatedPost,
    });
  } catch (error) {
    if (error.message === "Post not found") {
      res.status(404).json({ error: "Post not found" });
    } else {
      res.status(500).json({ error: "Internal Server Error" });
    }
  }
});

const PORT = 3000;
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```

### ১. ট্রানজ্যাকশন কন্টেক্সট তৈরি (`tx`)

`prisma.$transaction(async (tx) => { ... })`
এখানে আমরা ডাটাবেসকে বলছি, "আমি ভেতরে যে কাজগুলো করতে যাচ্ছি, সেগুলোকে একটি একক প্যাকেজ হিসেবে ধরো।" ট্রানজ্যাকশনের ভেতরে আমরা সাধারণ `prisma` এর বদলে `tx` ব্যবহার করি। এর ফলে যদি ভিউ আপডেট করার সময় কোনো সমস্যা হয়, তবে ডাটাবেস আগের অবস্থায় ফিরে যাবে (Rollback)।

### ২. বর্তমান ডাটা চেক করা (`findUnique`)

```javascript
const post = await tx.post.findUnique({ where: { id: postId } });
```

আপডেট করার আগে আমরা নিশ্চিত হচ্ছি যে ওই `id`-র কোনো পোস্ট আদৌ আছে কি না। যদি পোস্ট না থাকে, তবে কোডটি এরর থ্রো করবে এবং ট্রানজ্যাকশনটি ওখানেই থেমে যাবে। এটি ডাটা ইন্টিগ্রিটি বজায় রাখে।

### ৩. অ্যাটমিক ইনক্রিমেন্ট (`increment: 1`)

সবচাইতে গুরুত্বপূর্ণ অংশ হলো এটি:

```ts
        viewCount: {
            increment: 1, // ডাটাবেস লেভেলে +১ হবে
          }
```

এটি ডাটাবেসের কাছে একটি সরাসরি নির্দেশ। এটি এমন নয় যে "আগে ডাটা পড়ো, তারপর কোড দিয়ে ১ যোগ করো"। বরং এটি ডাটাবেস ইঞ্জিনকে বলে: **"তোমার কাছে বর্তমানে এই রো-তে যে সংখ্যা আছে, তার সাথে ১ যোগ করে দাও।"**

### ৪. রেস কন্ডিশন (Race Condition) রোধ

কেন আমরা `post.viewCount + 1` লিখলাম না?

- **ভুল পদ্ধতি:** যদি ইউজার A এবং ইউজার B একই সাথে ১০ ভিউ থাকা অবস্থায় পোস্টটি দেখে, তবে দুজনেই দেখবে ১০। ফলে দুজনই ১০+১ = ১১ আপডেট করবে। ভিউ ১টি হারিয়ে যাবে।
- **সঠিক পদ্ধতি (`increment`):** ডাটাবেস যখন দেখে দুজন একসাথে `increment` কমান্ড দিচ্ছে, তখন সে সিরিয়ালি (কিউ অনুযায়ী) একজনের পর একজন আপডেট করে। ফলে ১০ থেকে ১১, তারপর ১২ হয়। কোনো ভিউ মিস হয় না।

### ৫. রেজাল্ট রিটার্ন এবং কমিট (`Commit`)

সব কাজ শেষ হওয়ার পর `return updatedPost` করার মাধ্যমে ট্রানজ্যাকশনটি **Commit** হয়। অর্থাৎ ডাটাবেসে পরিবর্তনটি স্থায়ীভাবে সেভ হয়ে যায়। এরপর কনসোলে আমরা আপডেট হওয়া নতুন ভিউ সংখ্যাটি দেখতে পাই।

---

### সংক্ষেপে পুরো প্রক্রিয়া:

| ধাপ        | কাজ          | উদ্দেশ্য                               |
| ---------- | ------------ | -------------------------------------- |
| **Step 1** | `tx` শুরু    | কাজের নিরাপত্তা নিশ্চিত করা।           |
| **Step 2** | `findUnique` | আইডি সঠিক কি না তা যাচাই করা।          |
| **Step 3** | `increment`  | ডাটাবেস লেভেলে সরাসরি সংখ্যা ১ বাড়ানো। |
| **Step 4** | `return`     | ডাটা সেভ করা এবং রেজাল্ট পাঠানো।       |

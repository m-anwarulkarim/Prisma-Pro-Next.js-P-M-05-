# Cursor-based Pagination

সহজ কথায়, **Cursor-based Pagination** হলো একটি বুকমার্কের মতো। ধরুন আপনি একটি বিশাল মোটা বই পড়ছেন। আপনি কত নম্বর পেজ পড়েছেন সেটা মনে না রেখে, একটি সুতো বা বুকমার্ক দিয়ে রাখলেন যেখানে আপনি শেষ করেছিলেন। পরের বার আপনি সরাসরি ওই বুকমার্কের পর থেকে পড়া শুরু করবেন।

বড় বড় অ্যাপ যেমন ফেসবুক, ইনস্টাগ্রাম বা টুইটারে যখন আপনি স্ক্রল করেন, তখন এই পদ্ধতিটিই ব্যবহার হয়।

---

## ১. Cursor-based Pagination কীভাবে কাজ করে?

এখানে আমরা কোনো পেজ নম্বর দিয়ে ডাটা খুঁজি না। আমরা ডাটাবেসকে বলি: **"এই নির্দিষ্ট আইডি (বা ইউনিক কোনো ভ্যালু) এর পর থেকে আমাকে আরও ১০টি ডাটা দাও।"**

### মূল ৩টি জিনিস:

- **`cursor`**: আপনার শেষ দেখা আইটেমটির ইউনিক আইডি (বা ইউনিক কোনো কলাম)।
- **`take`**: আপনি কয়টি ডাটা নিতে চান।
- **`skip: 1`**: কার্সর হিসেবে যে আইডি দিয়েছেন, ডাটাবেস সাধারণত ওটাকেও রেজাল্টে রাখে। তাই ওই একই ডাটা বারবার না দেখানোর জন্য আমরা ১টি আইটেম স্কিপ করি।

---

## ২. প্র্যাকটিক্যাল উদাহরণ (Step by Step)

### প্রথমবার ডাটা আনা (Page 1):

প্রথমবার আমাদের কাছে কোনো কার্সর বা বুকমার্ক নেই। তাই আমরা শুধু `take` ব্যবহার করব।

```javascript
const firstPage = await prisma.post.findMany({
  take: 4,
  orderBy: { id: "asc" }, // কার্সর ব্যবহারের জন্য সর্টিং করা বাধ্যতামূলক
});

// শেষ আইটেমটির আইডি সেভ করে রাখি পরের বার ব্যবহারের জন্য
const lastItem = firstPage[firstPage.length - 1];
const myCursor = lastItem.id; // ধরুন আইডি আসলো ৫২
```

### দ্বিতীয়বার ডাটা আনা (Page 2):

এখন আমরা আগেরবার সেভ করা `myCursor` ব্যবহার করে ডাটা আনব।

```javascript
const secondPage = await prisma.post.findMany({
  take: 4,
  skip: 1, // কার্সর আইডি ৫২ কে বাদ দিয়ে তার পরের ৪টি নিবে
  cursor: {
    id: myCursor, // ৫২ নম্বর আইডি থেকে শুরু করো
  },
  orderBy: { id: "asc" },
});
```

---

## ৩. সুবিধা ও অসুবিধা

### সুবিধা (Pros) - কেন এটি সেরা?

- **বিশাল ডাটাতেও সুপার ফাস্ট:** ডাটাবেসকে লক্ষ লক্ষ ডাটা স্কিপ করতে হয় না। সে সরাসরি কার্সর আইডি খুঁজে বের করে এবং তার পরের কয়েকটা ডাটা নিয়ে আসে।
- **একই ডাটা দুবার আসে না:** যদি নতুন কোনো ডাটা ইনসার্ট হয়, তাহলেও আপনার সিরিয়াল নষ্ট হয় না, কারণ আপনি আইডির রেফারেন্স ধরে এগোচ্ছেন।

### অসুবিধা (Cons) - সীমাবদ্ধতা:

- **সরাসরি জাম্প করা যায় না:** আপনি সরাসরি পেজ নম্বর ৫ এ যেতে পারবেন না। আপনাকে ১, ২, ৩, ৪ হয়েই ৫ এ যেতে হবে।
- **ইউনিক কলাম লাগে:** কার্সর হিসেবে ব্যবহার করার জন্য অবশ্যই এমন একটি কলাম (যেমন ID বা Timestamp) লাগবে যা ইউনিক।

---

## ৪. গুরুত্বপূর্ণ কিছু টিপস

- **কেন `skip: 1` ব্যবহার করব?**
  যদি আপনি `skip: 1` না দেন, তবে রেজাল্টে আগের পেজের শেষ আইটেমটি আবার এই পেজের শুরুতে চলে আসবে।
- **পিছনের দিকে যাওয়া:**
  আপনি যদি উল্টো দিকে ডাটা আনতে চান (যেমন আগের ৪টি পোস্ট), তবে `take` এর মান নেগেটিভ (`-4`) করে দিন।

```javascript
const previousPage = await prisma.post.findMany({
  take: -4,
  skip: 1,
  cursor: { id: myCursor },
});
```

---

## ৫. বাস্তব জীবনে কখন কোনটি ব্যবহার করবেন?

| বৈশিষ্ট্য        | Offset Pagination (Skip/Take)       | Cursor Pagination (Cursor/Take)            |
| ---------------- | ----------------------------------- | ------------------------------------------ |
| **ব্যবহার**      | ই-কমার্স ওয়েবসাইট, ব্লগের পেজ নম্বর | ফেসবুক/ইনস্টাগ্রাম নিউজফিড, ইনফিনিট স্ক্রল |
| **পারফরম্যান্স** | ডাটা বাড়লে স্লো হয়ে যায়             | ডাটা বাড়লেও সবসময় ফাস্ট থাকে               |
| **নেভিগেশন**     | সরাসরি যেকোনো পেজে যাওয়া যায়        | শুধু নেক্সট বা প্রিভিয়াস করা যায়           |

===========================================================================================================

একটি বাস্তবধর্মী **Express.js API** উদাহরণ দেওয়া হলো। এখানে আমরা দেখব কীভাবে ফ্রন্টএন্ড থেকে কার্সর (Cursor) পাঠিয়ে পরবর্তী ডাটাগুলো আনা হয়।

### বাস্তব কোড উদাহরণ: Cursor-based API

এই এপিআই-তে ইউজার প্রথমবার কোনো কার্সর ছাড়াই রিকোয়েস্ট করবে, আর পরের বারগুলোতে আগের পাওয়া শেষ আইডির কার্সরটি পাঠাবে।

```javascript
const express = require("express");
const { PrismaClient } = require("@prisma/client");
const prisma = new PrismaClient();
const app = express();

app.get("/posts", async (req, res) => {
  // ১. req.query থেকে কার্সর আইডি এবং লিমিট নেওয়া
  const cursorId = req.query.cursor ? Number(req.query.cursor) : null;
  const limit = Number(req.query.limit) || 10;

  try {
    const posts = await prisma.post.findMany({
      take: limit,
      // ২. যদি কার্সর আইডি থাকে তবেই কার্সর অবজেক্টটি যোগ করা হবে
      ...(cursorId && {
        skip: 1, // আগের শেষ আইটেমটি বাদ দিতে
        cursor: { id: cursorId },
      }),
      orderBy: {
        id: "asc", // কার্সর সবসময় ইউনিক এবং সর্টেড কলামে হতে হয়
      },
    });

    // ৩. পরবর্তী কার্সর আইডি বের করা (রেজাল্টের শেষ আইটেমটির আইডি)
    const nextCursor =
      posts.length === limit ? posts[posts.length - 1].id : null;

    res.json({
      data: posts,
      nextCursor: nextCursor, // ফ্রন্টএন্ড এই আইডি ব্যবহার করে পরবর্তী পেজ কল করবে
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.listen(3000, () => console.log("Server running on port 3000"));
```

---

### এটি কীভাবে কাজ করবে? (Step-by-Step Flow)

#### ধাপ ১: প্রথমবার কল (Page 1)

ইউজার কল করবে: `GET /posts?limit=5`

- **Back-end:** `cursorId` নেই। তাই Prisma প্রথম ৫টি ডাটা আনবে।
- **Response:**

```json
{
  "data": [...5 items],
  "nextCursor": 45  // ধরুন শেষ আইটেমের আইডি ৪৫
}

```

#### ধাপ ২: দ্বিতীয়বার কল (Next Page/Infinite Scroll)

ইউজার এখন `nextCursor` এর মান ব্যবহার করে কল করবে: `GET /posts?limit=5&cursor=45`

- **Back-end:** `cursorId` এখন ৪৫।
- **Prisma:** এটি আইডি ৪৫ খুঁজে বের করবে, `skip: 1` এর কারণে ৪৫ কে বাদ দিবে এবং তার পরের ৫টি ডাটা নিয়ে আসবে।
- **Response:** নতুন ৫টি ডাটা এবং একটি নতুন `nextCursor` আসবে।

---

### কেন এই পদ্ধতিটি ?

১. **Performance:** আপনার ডাটাবেসে ১০ কোটি ডাটা থাকলেও, এটি সরাসরি আইডি ৪৫ থেকে খোঁজা শুরু করবে। তাই এটি সবসময় সুপার ফাস্ট।
২. **Infinite Scroll:** ফেসবুক বা ইউটিউবের মতো অ্যাপে যখন আপনি নিচে স্ক্রল করেন, ব্যাকএন্ডে এভাবেই কার্সর পাঠানো হয়।

**একটি ছোট টিপস:**
বাস্তব প্রজেক্টে কার্সর হিসেবে সবসময় এমন কিছু ব্যবহার করবেন যা **ইউনিক** (যেমন: `id` বা `createdAt`)। যদি `createdAt` ব্যবহার করেন, তবে খেয়াল রাখতে হবে যেন দুটি পোস্টের সময় একই না হয় (মিলি-সেকেন্ড পর্যন্ত চেক করা হয়)।

## ১. Offset-based Pagination & Sorting Helper

ক্লিন কোড (Clean Code) এবং DRY (Don't Repeat Yourself) প্রিন্সিপাল বজায় রাখার জন্য পেজিনেশন এবং সর্টিং লজিককে একটি আলাদা হেল্পার ফাংশনে রাখা অত্যন্ত কার্যকর। এটি কোডবেসকে মেইনটেনেবল এবং রিডেবল করে তোলে।

### ক. Pagination Helper এর প্রয়োজনীয়তা

বড় প্রজেক্টে অনেকগুলো মডেলে (যেমন: User, Product, Order) পেজিনেশন প্রয়োজন হয়। প্রতিবার ম্যানুয়ালি `skip` এবং `limit` ক্যালকুলেট না করে একটি সেন্ট্রাল হেল্পার ফাংশন ব্যবহার করা শ্রেয়।

#### হেল্পার ফাংশন (`src/helpers/paginationHelper.ts`):

```typescript
type IOptions = {
  page?: number | string;
  limit?: number | string;
  sortBy?: string;
  sortOrder?: "asc" | "desc";
};

type IOptionsResult = {
  page: number;
  limit: number;
  skip: number;
  sortBy: string;
  sortOrder: "asc" | "desc";
};

const calculatePagination = (options: IOptions): IOptionsResult => {
  // ১. ইনপুটকে নম্বরে কনভার্ট করা (ডিফল্ট ভ্যালুসহ)
  const page = Number(options.page) || 1;
  const limit = Number(options.limit) || 10;

  // ২. স্কিপ ক্যালকুলেশন: (বর্তমান পেজ - ১) * লিমিট
  const skip = (page - 1) * limit;

  // ৩. সর্টিং সেটআপ
  const sortBy = options.sortBy || "createdAt";
  const sortOrder = (options.sortOrder as "asc" | "desc") || "desc";

  return {
    page,
    limit,
    skip,
    sortBy,
    sortOrder,
  };
};

export const paginationHelper = {
  calculatePagination,
};
```

এই কোডটুকু মূলত **Pagination (পেজিনেশন)** এবং **Sorting (সর্টিং)** এর মূল লজিক। নিচে এর প্রতিটি অংশ সহজভাবে ব্যাখ্যা করা হলো:

### ১. ডিফল্ট ভ্যালু সেট করা (Page & Limit)

```javascript
const page = Number(options.page) || 1;
const limit = Number(options.limit) || 10;
```

- **কাজ:** ইউজার যদি কোনো পেজ নম্বর বা লিমিট না পাঠায়, তবে এটি ডিফল্ট হিসেবে ১ নম্বর পেজ এবং প্রতি পেজে ১০টি করে ডেটা দেখানোর সেটআপ করে।
- `Number()` ব্যবহার করা হয়েছে যাতে স্ট্রিং ইনপুট আসলেও তা সংখ্যায় কনভার্ট হয়ে যায়।

### ২. স্কিপ ক্যালকুলেশন (Skip Calculation)

```javascript
const skip = (page - 1) * limit;
```

- **কাজ:** ডাটাবেজ থেকে ডেটা পড়ার সময় শুরুতে কয়টি ডেটা বাদ দিতে হবে তা বের করা।
- **উদাহরণ:** আপনি যদি ২ নম্বর পেজে যেতে চান এবং প্রতি পেজে ১০টি ডেটা থাকে, তবে সূত্র অনুযায়ী: `(2 - 1) * 10 = 10`। অর্থাৎ, ডাটাবেজ প্রথম ১০টি ডেটা **Skip** করে ১১ নম্বর থেকে দেখানো শুরু করবে।

### ৩. সর্টিং সেটআপ (Sorting Setup)

```javascript
const sortBy = options.sortBy || "createdAt";
const sortOrder = (options.sortOrder as "asc" | "desc") || "desc";

```

- **sortBy:** ডেটা কিসের ভিত্তিতে সাজানো হবে (যেমন: নাম, দাম বা তৈরির সময়)। কিছু না দিলে এটি `createdAt` অনুযায়ী সাজাবে।
- **sortOrder:** সাজানোর ক্রম। এটি হয় **asc** (ছোট থেকে বড়) অথবা **desc** (বড় থেকে ছোট) হবে। ডিফল্ট হিসেবে নতুন ডেটা আগে দেখানোর জন্য `desc` রাখা হয়েছে।

### ৪. আউটপুট রিটার্ন

```javascript
return { page, limit, skip, sortBy, sortOrder };
```

- সবশেষে ক্যালকুলেশন করা এই মানগুলো একটি অবজেক্ট আকারে পাঠিয়ে দেওয়া হয়, যা সরাসরি Prisma-র `findMany` কুয়েরিতে ব্যবহার করা যায়।

---

**সংক্ষেপে:** এই ফাংশনটি ইউজারের রিকোয়েস্ট থেকে তথ্য নিয়ে হিসাব করে বের করে যে— ডাটাবেজ থেকে **কয়টি ডেটা বাদ দিতে হবে (skip)**, **কয়টি নিতে হবে (limit)** এবং **কীভাবে সাজাতে হবে (sort)**।

### খ. API Implementation (ব্যবহারিক প্রয়োগ)

নিচে এক্সপ্রেস (Express) কন্ট্রোলারে এর টাইপ-সেফ ব্যবহার দেখানো হলো:

```typescript
import { Request, Response } from "express";
import { paginationHelper } from "./helpers/paginationHelper";
import prisma from "./lib/prisma";

app.get("/products", async (req: Request, res: Response) => {
  try {
    // হেল্পার ফাংশন ব্যবহার করে অপশনগুলো জেনারেট করা
    const paginationOptions = paginationHelper.calculatePagination(req.query);

    // Prisma কুয়েরিতে টাইপ-সেফ অপশনগুলো বসানো
    const result = await prisma.product.findMany({
      skip: paginationOptions.skip,
      take: paginationOptions.limit,
      orderBy: {
        // ডাইনামিক কি (Key) ব্যবহারের জন্য [] ব্যবহার করা হয়েছে
        [paginationOptions.sortBy]: paginationOptions.sortOrder,
      },
    });

    // মেটাডেটার জন্য মোট রেকর্ড সংখ্যা বের করা
    const total = await prisma.product.count();

    res.status(200).json({
      success: true,
      meta: {
        page: paginationOptions.page,
        limit: paginationOptions.limit,
        total,
        totalPages: Math.ceil(total / paginationOptions.limit),
      },
      data: result,
    });
  } catch (error: any) {
    res.status(500).json({ success: false, message: error.message });
  }
});
```

এই কোডটুকু হলো একটি এপিআই কন্ট্রোলারের মূল অংশ, যেখানে হেল্পার ফাংশন থেকে পাওয়া মানগুলো ব্যবহার করে ডাটাবেজ থেকে ডেটা নিয়ে আসা হয়েছে। নিচে এর প্রতিটি অংশ বিস্তারিত ব্যাখ্যা করা হলো:

### ১. হেল্পার ফাংশন থেকে ডাটা নেওয়া

```typescript
const paginationOptions = paginationHelper.calculatePagination(req.query);
```

- **কাজ:** ইউজার ইউআরএল-এ যে কুয়েরি প্যারামিটারগুলো পাঠিয়েছে (যেমন: `?page=2&limit=5`), সেগুলো হেল্পার ফাংশনে পাঠানো হয়েছে। হেল্পার ফাংশনটি হিসাব করে আমাদের `skip`, `limit`, `sortBy`, এবং `sortOrder` সম্বলিত একটি অবজেক্ট ফেরত দিচ্ছে।

---

### ২. Prisma-র মাধ্যমে ডেটা ফেচ করা

```typescript
const result = await prisma.product.findMany({
  skip: paginationOptions.skip,
  take: paginationOptions.limit,
  orderBy: {
    [paginationOptions.sortBy]: paginationOptions.sortOrder,
  },
});
```

- **`skip`:** ডাটাবেজের শুরুর দিক থেকে কয়টি ডেটা বাদ দিতে হবে।
- **`take`:** স্কিপ করার পর ঠিক কয়টি ডেটা তুলে আনতে হবে (এটিই মূলত আপনার `limit`)।
- **`orderBy`:** এখানে `[paginationOptions.sortBy]` ব্যবহার করা হয়েছে ডাইনামিক সর্টিংয়ের জন্য। থার্ড ব্র্যাকেট দেওয়ার মানে হলো, ভেরিয়েবলের ভেতরে যে স্ট্রিংটি আছে (যেমন: 'price' বা 'createdAt'), সেটিই অবজেক্টের **Key** হিসেবে কাজ করবে।

---

### ৩. মোট রেকর্ডের সংখ্যা গণনা

```typescript
const total = await prisma.product.count();
```

- **কাজ:** আপনার `product` টেবিলে মোট কতটি ডেটা আছে তা বের করা। এটি দরকার কারণ ফ্রন্টএন্ডে মোট কয়টি পেজ হবে তা দেখানোর জন্য মোট আইটেম সংখ্যা জানা প্রয়োজন।

---

### ৪. রেসপন্স এবং মেটাডেটা (Metadata) তৈরি

```typescript
res.status(200).json({
  success: true,
  meta: {
    page: paginationOptions.page,
    limit: paginationOptions.limit,
    total,
    totalPages: Math.ceil(total / paginationOptions.limit),
  },
  data: result,
});
```

- **`meta`:** এখানে ইউজারের সুবিধার জন্য কিছু অতিরিক্ত তথ্য পাঠানো হয়।
- **`totalPages`:** মোট আইটেমকে (`total`) প্রতি পেজের লিমিট দিয়ে ভাগ করে `Math.ceil()` করা হয়েছে। `Math.ceil` ব্যবহারের কারণ হলো, যদি ভাগে দশমিক আসে (যেমন: ৫.২), তবে তাকে পূর্ণসংখ্যায় (৬) রূপান্তর করা, যাতে শেষ আইটেমগুলোর জন্য একটি আলাদা পেজ তৈরি হয়।
- **`data`:** এখানে ডাটাবেজ থেকে আসা আসল প্রোডাক্টের লিস্টটি থাকে।

---

#### শর্ত অনুযায়ী মোট (Total) সংখ্যা বের করা

```ts
const total = await prisma.post.count({
  where: whereConditions, //
});
```

### সংক্ষেপে নোট:

এই পুরো প্রসেসটি নিশ্চিত করে যে, আপনার এপিআই খুব অল্প মেমরি খরচ করে ডাটাবেজ থেকে শুধু প্রয়োজনীয় ডেটাটুকু নিয়ে আসছে এবং ফ্রন্টএন্ডকে জানাচ্ছে যে আরও কতগুলো পেজ বাকি আছে।

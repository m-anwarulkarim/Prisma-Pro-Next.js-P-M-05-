transaction()

### বাস্তব কোড উদাহরণ: Offset-based API

**Offset Pagination**-এর একটি পূর্ণাঙ্গ বাস্তব উদাহরণ নিচে দেওয়া হলো। এটি সাধারণ ই-কমার্স বা ব্লগ সাইটের জন্য সবচেয়ে বেশি ব্যবহৃত হয় যেখানে নিচে ১, ২, ৩ নম্বর পেজ বাটন থাকে।

এপিআই-তে ইউজার কত নম্বর পেজ (`page`) এবং প্রতি পেজে কয়টি ডেটা (`limit`) চায় তা পাঠাবে।

```javascript
const express = require("express");
const { PrismaClient } = require("@prisma/client");
const prisma = new PrismaClient();
const app = express();

app.get("/products", async (req, res) => {
  // ১. req.query থেকে পেজ নম্বর এবং লিমিট (মানে পেজ সাইজ) নেওয়া
  const page = Number(req.query.page) || 1; // কিছু না দিলে ১ম পেজ
  const limit = Number(req.query.limit) || 10; // কিছু না দিলে ১০টি আইটেম

  // ২. ক্যালকুলেশন: কতগুলো ডেটা স্কিপ করতে হবে
  // সূত্র: (বর্তমান পেজ - ১) * লিমিট
  const skipAmount = (page - 1) * limit;

  try {
    // ৩. Prisma কুয়েরি চালানো
    // এখানে আমরা মোট ডেটা সংখ্যাও গুনে নিব যাতে ফ্রন্টএন্ডে পেজ বাটন বানানো সহজ হয়
    const [totalItems, products] = await prisma.$transaction([
      prisma.product.count(), // মোট কতটি প্রোডাক্ট আছে
      prisma.product.findMany({
        skip: skipAmount,
        take: limit,
        orderBy: { id: "desc" }, // নতুন প্রোডাক্টগুলো আগে দেখাবে
      }),
    ]);

    // ৪. রেসপন্স পাঠানো
    res.json({
      meta: {
        totalItems,
        totalPages: Math.ceil(totalItems / limit),
        currentPage: page,
        pageSize: limit,
      },
      data: products,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.listen(3000, () => console.log("Offset API running on port 3000"));
```

---

### এটি যেভাবে কাজ করে (Request Flow)

ধরা যাক ডেটাবেসে মোট **৫০টি** প্রোডাক্ট আছে।

#### ১. প্রথম পেজের জন্য কল:

ইউজার কল করবে: `GET /products?page=1&limit=10`

- **হিসাব:** `skip = (1-1) * 10 = 0`
- **ফলাফল:** Prisma প্রথম ১০টি প্রোডাক্ট নিয়ে আসবে।

#### ২. সরাসরি ৫ম পেজে যাওয়ার জন্য কল:

ইউজার কল করবে: `GET /products?page=5&limit=10`

- **হিসাব:** `skip = (5-1) * 10 = 40`
- **ফলাফল:** Prisma প্রথম ৪০টি প্রোডাক্ট বাদ (skip) দিয়ে ৪১ থেকে ৫০ নম্বর প্রোডাক্টগুলো নিয়ে আসবে।

---

### Offset vs Cursor: মূল পার্থক্য যখন আপনি কোড করবেন

| বিষয়                       | Offset (এই কোডটি)              | Cursor (আগের কোডটি)                         |
| -------------------------- | ------------------------------ | ------------------------------------------- |
| **প্যারামিটার**            | `page` এবং `limit` ব্যবহার হয়। | `cursor` এবং `limit` ব্যবহার হয়।            |
| **হিসাব**                  | `(page - 1) * limit` করতে হয়।  | কোনো জটিল হিসাব নেই, শুধু আইডি পাস করতে হয়। |
| **Prisma কী ব্যবহার করে?** | `skip` এবং `take`              | `cursor`, `skip: 1` এবং `take`              |
| **বেস্ট ইউজ কেস**          | পেজ বাটন (১, ২, ৩...) থাকলে।   | ইনফিনিট স্ক্রল (ফেসবুক স্টাইল) থাকলে।       |

---

### একটি গুরুত্বপূর্ণ নোট:

**Offset Pagination**-এ যখন `skip: 100000` করবেন, ডাটাবেসকে কিন্তু সত্যিই ১ লাখ ডাটা গুনতে হয়, যা অনেক স্লো। তাই আপনার প্রজেক্টের ডাটা যদি অনেক বেশি হয় (যেমন কয়েক লাখ), তবেই কেবল **Cursor** পদ্ধতিতে যাওয়ার চিন্তা করবেন। ছোট প্রজেক্টে **Offset**-ই সেরা কারণ এটি ব্যবহার করা অনেক সহজ।

==================================================================================

## transaction

Prisma-তে **`$transaction`** মূলত একটি "সব অথবা কিছুই না" (All or Nothing) নীতিতে কাজ করে। এটি ব্যবহার করার প্রধান কারণ হলো একাধিক কুয়েরিকে একটি প্যাকেজে বন্দি করা।

সহজ কথায়, আপনি যদি ডেটাবেসে ২-৩টি কাজ একসাথে করতে চান এবং চান যে **সবগুলো সফল হলেই কেবল ডেটা সেভ হবে**, আর **একটিও যদি ভুল হয় তবে কোনো কাজই সেভ হবে না**, তখনই `$transaction` ব্যবহার করা হয়।

আপনার Pagination এর উদাহরণে আমি কেন এটি ব্যবহার করেছি এবং এর কাজ কী, তা নিচে বুঝিয়ে দিচ্ছি:

---

### ১. Pagination-এ কেন ব্যবহার করলাম?

আমার আগের উদাহরণে আমরা দুটি কাজ করেছি:

- `prisma.product.count()`: মোট কয়টি প্রোডাক্ট আছে তা গুনেছি।
- `prisma.product.findMany()`: নির্দিষ্ট পেজের ডেটাগুলো এনেছি।

যদি আমরা আলাদাভাবে লিখতাম:

```javascript
const totalItems = await prisma.product.count();
const products = await prisma.product.findMany({ skip: 0, take: 10 });
```

এখানে সমস্যা হলো, প্রথম লাইন শেষ হওয়ার পর দ্বিতীয় লাইন চলার মাঝখানে যদি কেউ নতুন ১টি প্রোডাক্ট ডিলিট করে দেয়, তবে আপনার `totalItems` এর সংখ্যা ভুল হয়ে যেতে পারে (Data Inconsistency)।

**`$transaction`** ব্যবহার করলে ডেটাবেস এই দুটি কাজকে একটি সিঙ্গেল ইউনিট হিসেবে দেখে, যা রেজাল্টকে আরও নির্ভুল (Consistent) করে।

---

### ২. বাস্তব জীবনের সেরা উদাহরণ: টাকা পাঠানো

ধরুন আপনি আপনার বন্ধুকে ৫০০ টাকা পাঠাবেন। এখানে দুটি কাজ হবে:

1. আপনার একাউন্ট থেকে ৫০০ টাকা **কমবে**।
2. আপনার বন্ধুর একাউন্টে ৫০০ টাকা **বাড়বে**।

**সমস্যা:** যদি ১ম কাজ সফল হওয়ার পর সার্ভার ডাউন হয়ে যায় এবং ২য় কাজটা না হয়, তবে আপনার টাকা হারিয়ে যাবে!

**সমাধান ($transaction):**

```javascript
await prisma.$transaction([
  prisma.user.update({
    where: { id: 1 },
    data: { balance: { decrement: 500 } },
  }),
  prisma.user.update({
    where: { id: 2 },
    data: { balance: { increment: 500 } },
  }),
]);
```

এখানে যদি কোনো কারণে বন্ধুর একাউন্টে টাকা যোগ হতে না পারে, তবে Prisma আপনার একাউন্ট থেকে টাকা কাটার কাজটিকেও বাতিল (Rollback) করে দেবে। অর্থাৎ আপনার টাকা আপনার কাছেই থাকবে।

---

### ৩. Prisma-তে এটি ২ ভাবে করা যায়:

#### ক) Sequential Transaction (Array পদ্ধতি):

এটি সবচেয়ে সহজ। একটি অ্যারের ভেতর কুয়েরিগুলো লিখে দিলে তারা সিরিয়ালি চলে। (আমি Pagination এ এটিই ব্যবহার করেছি)।

```javascript
const [res1, res2] = await prisma.$transaction([query1, query2]);
```

#### খ) Interactive Transaction (Function পদ্ধতি):

যদি একটি কুয়েরির রেজাল্টের ওপর ভিত্তি করে অন্য কুয়েরি লিখতে হয়, তখন এটি লাগে।

```javascript
await prisma.$transaction(async (tx) => {
  const user = await tx.user.findUnique({ ... });
  if (user.balance < 500) throw new Error("টাকা নেই!"); // ট্রানজ্যাকশন ক্যানসেল হবে

  await tx.user.update({ ... });
});

```

### ১. কেন এখানে ফাংশন/কলব্যাক ব্যবহার করা হয়?

ট্রানজ্যাকশনের ভেতরে একটি ফাংশন গ্রহণ করার পেছনে সুনির্দিষ্ট কিছু কারিগরি কারণ রয়েছে:

- **শর্তাধীন সিদ্ধান্ত গ্রহণ (Conditional Logic):** এই পদ্ধতিতে প্রথম কুয়েরির ফলাফল একটি ভেরিয়েবলে সংরক্ষণ করা যায় এবং সেই ভেরিয়েবলের মানের ওপর ভিত্তি করে `if-else` লজিক প্রয়োগ করা সম্ভব। সাধারণ অ্যারে মেথডে এটি সম্ভব নয়।
- **তথ্যের নির্ভরতা (Data Dependency):** যদি দ্বিতীয় কুয়েরিটি প্রথম কুয়েরির আউটপুটের ওপর সরাসরি নির্ভরশীল হয়, তবে ফাংশন ব্যবহারের মাধ্যমে সেই ডেটা পরবর্তী ধাপে পাস করা যায়।
- **সমন্বিত রোলব্যাক (Atomic Rollback):** ফাংশনের ভেতরে কোনো পর্যায়ে `throw new Error()` কার্যকর হলে প্রিজমা সম্পূর্ণ ট্রানজ্যাকশনটি বাতিল করে দেয়। এতে ডাটাবেজের তথ্যের কোনো অসঙ্গতি তৈরি হয় না।

####

**`tx` ক্লায়েন্টের ব্যবহার:** ট্রানজ্যাকশন ব্লকের ভেতরে অবশ্যই প্যারামিটার হিসেবে পাওয়া `tx` ক্লায়েন্ট ব্যবহার করতে হবে। মূল `prisma` ক্লায়েন্ট ব্যবহার করলে তা ট্রানজ্যাকশনের অংশ হিসেবে গণ্য হবে না।
